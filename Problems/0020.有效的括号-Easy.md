# 有效的括号

> Easy

## 题目

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

- 左括号必须用相同类型的右括号闭合。
- 左括号必须以正确的顺序闭合。
- 每个右括号都有一个对应的相同类型的左括号。

### 示例 1

```c
输入：s = "()"
输出：true
```

### 示例 2

```c
输入：s = "(){[]}"
输出：true
```

### 示例 3

```c
输入：s = "(]"
输出：false
```

### 提示

- `1 <= s.length <= 10000`
- `s` 仅由括号 `'()[]{}'` 组成

## 已给代码

```c
/*
 * @lc app=leetcode.cn id=20 lang=c
 *
 * [20] 有效的括号
 */

// @lc code=start
bool isValid(char *s) {

}
// @lc code=end

```

## 解析

很典型的`栈`的运用，先进后出，主要判断读取到右括号时，若上一个是与之匹配的左括号，则可以将两者`消掉`（简单的做法就是栈指针往前挪），若

- 前面没有括号了
- 上一个不是与之匹配的左括号

则说明`s`不匹配，最后再判断有没有残余的左括号即可。

可以用数组实现栈的功能，也可以单独创建一个栈，甚至还可以做一个链式栈（本质是链表），但未免有些大材小用了。

## 题解

```c
bool isValid(char *s) {
  char brackets[10000];
  int i = 0, j = 0; // i用于遍历字符串s，j用于记录brackests中括号的个数
  while (s[i] != '\0') {
    if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
      brackets[j] = s[i];
      j++;        // brackets中括号的个数加1,j指向下一个位置
    } else {      // 如果s[i]是右括号
      if (j == 0) // 如果brackets中没有括号，说明s中的括号不匹配
        return false;
      if (s[i] == ')' && brackets[j - 1] == '(') {
        j--; // brackets中括号的个数减1,j指向上一个位置
      } else if (s[i] == ']' && brackets[j - 1] == '[') {
        j--;
      } else if (s[i] == '}' && brackets[j - 1] == '{') {
        j--;
      } else
        return false;
    }
    i++; // 遍历下一个字符
  }
  if (j == 0) // 如果brackets中没有括号，说明s中的括号匹配
    return true;
  else
    return false;
}
```
