# 1.两数之和——Easy

## 题目

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

### 示例 1

```c
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

### 示例 2

```c
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

### 示例 3

```c
输入：nums = [3,3], target = 6
输出：[0,1]
```

### 提示

```c
2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
只会存在一个有效答案
```

### 进阶

```c
你可以想出一个时间复杂度小于 O(n2) 的算法吗？
```

## 所给代码

```c
/*
 * @lc app=leetcode.cn id=1 lang=c
 *
 * [1] 两数之和
 */

// @lc code=start
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* twoSum(int* nums, int numsSize, int target, int* returnSize) {

}
// @lc code=end
```

## 解析

很容易想到，我们只要将数组中每两个数加起来与目标值比较就行了，所以我们可以使用两个`for循环`。

### 注意

1. 内外两层循环的对象、起始值、终止值；
2. 我们需要自己定义一个用于返回的数组，但是不能直接用`int result[*returnSize]`，因为这个数组是在**栈**上分配的局部变量，当函数返回时，它会被自动销毁，所以这里我用`stdlib.h`中的`malloc`函数为其分配内存，这样它会存在**堆**中，函数返回时它也不会被销毁。

## 题解

```c
#include <stdlib.h>
int *twoSum(int *nums, int numsSize, int target, int *returnSize) {
  //先分析参数，第一个是所给数组；第二个是数组大小；第三个是目标值；第四个是返回数组的大小
  *returnSize = 2;  //示例中数组大小均为2，那我们也设为2好了
  //为返回数组分配大小为两个int的内存
  int *result = (int *)malloc(sizeof(int) * (*returnSize));
  //嵌套循环
  for (int i = 0; i < numsSize; i++) {
    for (int j = i + 1; j < numsSize; j++) {
      //判断数组中两个数之和是否与目标值相等
      if (nums[i] + nums[j] == target) {
        result[0] = i;
        result[1] = j;
        return result;
      }
    }
  }
  return NULL;
}
```
