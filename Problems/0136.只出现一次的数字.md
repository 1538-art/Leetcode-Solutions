# 136. 只出现一次的数字

> Easy

## 题目

给你一个 `非空` 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

### 示例 1

```
输入：nums = [2,2,1]
输出：1
```

### 示例 2

```
输入：nums = [4,1,2,1,2]
输出：4
```

### 示例 3

```
输入：nums = [1]
输出：1
```

### 提示

```
1 <= nums.length <= 3 * 10^4
-3 * 10^4 <= nums[i] <= 3 * 10^4
除了某个元素只出现一次以外，其余每个元素均出现两次。
```


## 所给代码

```c
int singleNumber(int* nums, int numsSize) {
    
}
```

## 解析

这道题目第一眼看上去就容易想到哈希表，即通过将数字映射到哈希表中，来计数每一个数字出现的次数，最后找到次数为1的数输出即可，这种方式是非常符合直觉的，虽然不符合题目中的附加要求，但仍在文末给出了其C++实现。

言归正传，这个问题最巧妙的地方在于，是利用了异或这种运算的性质来解决的。
异或的运算法则一句话概括即：不同为1，相同为0；它是位运算的一种，即直接对在内存中的每一个二进制位进行操作(所以5异或2并不等于1)。基于此，它有一系列美妙的性质，这里只介绍归零性：即一个数与自己异或结果为零。基于这个性质，这道题的解也就不言自明了。

这个问题虽然非常简单，但是提供了一个平时不易想到的方向，位运算是非常底层的运算，具有非常小的时间开销，希望此题能为你打开位运算的大门。\^\-\^

## 题解

```c
int singleNumber(int* nums, int numsSize) {
    int x = 0;
    for (int i = 0; i < numsSize; i++) {
        x ^= nums[i];
    }
    return x;
}
```

### "错误的"解决方案

```c++
//C++,C写不来orz
int singleNumber(vector<int>& nums) {
    unordered_map<int, int> map;
    
    for (int num : nums) {
        map[num]++;
    }

    for (auto entry : map) {
        if (entry.second == 1) {
            return entry.first;
        }
    }

    return 0;
}
```



